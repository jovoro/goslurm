// Package goslurm provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package goslurm

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"gopkg.in/yaml.v2"

	"github.com/oapi-codegen/runtime"
)

const (
	TokenScopes = "token.Scopes"
	UserScopes  = "user.Scopes"
)

// Defines values for V0038JobPropertiesExclusive.
const (
	False V0038JobPropertiesExclusive = "false"
	Mcs   V0038JobPropertiesExclusive = "mcs"
	True  V0038JobPropertiesExclusive = "true"
	User  V0038JobPropertiesExclusive = "user"
)

// Defines values for V0038JobPropertiesGresFlags.
const (
	DisableBinding V0038JobPropertiesGresFlags = "disable-binding"
	EnforceBinding V0038JobPropertiesGresFlags = "enforce-binding"
)

// Defines values for V0038JobPropertiesOpenMode.
const (
	Append   V0038JobPropertiesOpenMode = "append"
	Truncate V0038JobPropertiesOpenMode = "truncate"
)

// Defines values for V0038PingPing.
const (
	DOWN V0038PingPing = "DOWN"
	UP   V0038PingPing = "UP"
)

// Defines values for V0038Signal.
const (
	ABRT V0038Signal = "ABRT"
	ALRM V0038Signal = "ALRM"
	CONT V0038Signal = "CONT"
	HUP  V0038Signal = "HUP"
	INT  V0038Signal = "INT"
	KILL V0038Signal = "KILL"
	QUIT V0038Signal = "QUIT"
	STOP V0038Signal = "STOP"
	TERM V0038Signal = "TERM"
	TSTP V0038Signal = "TSTP"
	TTIN V0038Signal = "TTIN"
	TTOU V0038Signal = "TTOU"
	URG  V0038Signal = "URG"
	USR1 V0038Signal = "USR1"
	USR2 V0038Signal = "USR2"
)

// V0038Diag defines model for v0.0.38_diag.
type V0038Diag struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`
	Meta   *V0038Meta    `json:"meta,omitempty"`

	// Statistics Slurm statistics
	Statistics *struct {
		// AgentCount Agent count
		AgentCount *int `json:"agent_count,omitempty"`

		// AgentQueueSize Agent queue size
		AgentQueueSize *int `json:"agent_queue_size,omitempty"`

		// AgentThreadCount Agent thread count
		AgentThreadCount *int `json:"agent_thread_count,omitempty"`

		// BfActive Backfill Schedule currently active
		BfActive *bool `json:"bf_active,omitempty"`

		// BfBackfilledHetJobs Total backfilled heterogeneous job components
		BfBackfilledHetJobs *int `json:"bf_backfilled_het_jobs,omitempty"`

		// BfBackfilledJobs Total backfilled jobs (since last slurm start)
		BfBackfilledJobs *int `json:"bf_backfilled_jobs,omitempty"`

		// BfCycleCounter Backfill Schedule Total cycles
		BfCycleCounter *int `json:"bf_cycle_counter,omitempty"`

		// BfCycleLast Backfill Schedule Last cycle time
		BfCycleLast *int `json:"bf_cycle_last,omitempty"`

		// BfCycleMax Backfill Schedule Max cycle time
		BfCycleMax *int `json:"bf_cycle_max,omitempty"`

		// BfCycleMean Backfill Schedule Mean cycle
		BfCycleMean *int `json:"bf_cycle_mean,omitempty"`

		// BfDepthMean Backfill Schedule Depth Mean
		BfDepthMean *int `json:"bf_depth_mean,omitempty"`

		// BfDepthMeanTry Backfill Schedule Depth Mean (try sched)
		BfDepthMeanTry *int `json:"bf_depth_mean_try,omitempty"`

		// BfLastBackfilledJobs Total backfilled jobs (since last stats cycle start)
		BfLastBackfilledJobs *int `json:"bf_last_backfilled_jobs,omitempty"`

		// BfLastDepth Backfill Schedule Last depth cycle
		BfLastDepth *int `json:"bf_last_depth,omitempty"`

		// BfLastDepthTry Backfill Schedule Mean cycle (try sched)
		BfLastDepthTry *int `json:"bf_last_depth_try,omitempty"`

		// BfQueueLen Backfill Schedule Last queue length
		BfQueueLen *int `json:"bf_queue_len,omitempty"`

		// BfQueueLenMean Backfill Schedule Mean queue length
		BfQueueLenMean *int `json:"bf_queue_len_mean,omitempty"`

		// BfTableSize Backfill Schedule Last table size
		BfTableSize *int `json:"bf_table_size,omitempty"`

		// BfTableSizeMean Backfill Schedule Mean table size
		BfTableSizeMean *int `json:"bf_table_size_mean,omitempty"`

		// BfWhenLastCycle Last cycle timestamp
		BfWhenLastCycle *int `json:"bf_when_last_cycle,omitempty"`

		// DbdAgentQueueSize DBD Agent queue size
		DbdAgentQueueSize *int `json:"dbd_agent_queue_size,omitempty"`

		// GettimeofdayLatency Latency for 1000 calls to gettimeofday()
		GettimeofdayLatency *int `json:"gettimeofday_latency,omitempty"`

		// JobStatesTs Job states timestamp
		JobStatesTs *int `json:"job_states_ts,omitempty"`

		// JobsCanceled Job cancelled
		JobsCanceled *int `json:"jobs_canceled,omitempty"`

		// JobsCompleted Job completed
		JobsCompleted *int `json:"jobs_completed,omitempty"`

		// JobsFailed Job failed
		JobsFailed *int `json:"jobs_failed,omitempty"`

		// JobsPending Job pending
		JobsPending *int `json:"jobs_pending,omitempty"`

		// JobsRunning Job running
		JobsRunning *int `json:"jobs_running,omitempty"`

		// JobsStarted Job started
		JobsStarted *int `json:"jobs_started,omitempty"`

		// JobsSubmitted Job submitted
		JobsSubmitted *int `json:"jobs_submitted,omitempty"`

		// PartsPacked partition records packed
		PartsPacked *int `json:"parts_packed,omitempty"`

		// ReqTime generation time
		ReqTime *int `json:"req_time,omitempty"`

		// ReqTimeStart data since
		ReqTimeStart *int `json:"req_time_start,omitempty"`

		// RpcsByMessageType Remote Procedure Call statistics by message type
		RpcsByMessageType *[]V0038DiagRpcm `json:"rpcs_by_message_type,omitempty"`

		// RpcsByUser Remote Procedure Call statistics by user
		RpcsByUser *[]V0038DiagRpcu `json:"rpcs_by_user,omitempty"`

		// ScheduleCycleLast Main Schedule last cycle
		ScheduleCycleLast *int `json:"schedule_cycle_last,omitempty"`

		// ScheduleCycleMax Main Schedule max cycle
		ScheduleCycleMax *int `json:"schedule_cycle_max,omitempty"`

		// ScheduleCycleMean Average time for Schedule Max cycle
		ScheduleCycleMean *int `json:"schedule_cycle_mean,omitempty"`

		// ScheduleCycleMeanDepth Average depth for Schedule Max cycle
		ScheduleCycleMeanDepth *int `json:"schedule_cycle_mean_depth,omitempty"`

		// ScheduleCyclePerMinute Main Schedule Cycles per minute
		ScheduleCyclePerMinute *int `json:"schedule_cycle_per_minute,omitempty"`

		// ScheduleCycleTotal Main Schedule cycle iterations
		ScheduleCycleTotal *int `json:"schedule_cycle_total,omitempty"`

		// ScheduleQueueLength Main Schedule Last queue length
		ScheduleQueueLength *int `json:"schedule_queue_length,omitempty"`

		// ServerThreadCount Server thread count
		ServerThreadCount *int `json:"server_thread_count,omitempty"`
	} `json:"statistics,omitempty"`
}

// V0038DiagRpcm defines model for v0.0.38_diag_rpcm.
type V0038DiagRpcm struct {
	// AverageTime average time
	AverageTime *int `json:"average_time,omitempty"`

	// Count rpc count
	Count *int `json:"count,omitempty"`

	// MessageType message type
	MessageType *string `json:"message_type,omitempty"`

	// TotalTime total time
	TotalTime *int `json:"total_time,omitempty"`

	// TypeId message type id
	TypeId *int `json:"type_id,omitempty"`
}

// V0038DiagRpcu defines model for v0.0.38_diag_rpcu.
type V0038DiagRpcu struct {
	// AverageTime average time
	AverageTime *int `json:"average_time,omitempty"`

	// Count rpc count
	Count *int `json:"count,omitempty"`

	// TotalTime total time
	TotalTime *int `json:"total_time,omitempty"`

	// User user
	User *string `json:"user,omitempty"`

	// UserId user id
	UserId *int `json:"user_id,omitempty"`
}

// V0038Error defines model for v0.0.38_error.
type V0038Error struct {
	// Error error message
	Error *string `json:"error,omitempty"`

	// ErrorNumber Slurm internal error number
	ErrorNumber *int `json:"error_number,omitempty"`
}

// V0038Errors Slurm errors
type V0038Errors = []V0038Error

// V0038JobProperties defines model for v0.0.38_job_properties.
type V0038JobProperties struct {
	// Account Charge resources used by this job to specified account.
	Account *string `json:"account,omitempty"`

	// AccountGatherFrequency Define the job accounting and profiling sampling intervals.
	AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

	// Argv Arguments to the script.
	Argv *[]string `json:"argv,omitempty"`

	// Array Submit a job array, multiple jobs to be executed with identical parameters. The indexes specification identifies what array index values should be used.
	Array *string `json:"array,omitempty"`

	// BatchFeatures features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BeginTime Submit the batch script to the Slurm controller immediately, like normal, but tell the controller to defer the allocation of the job until the specified time.
	BeginTime *int64 `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specification.
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraint Specifies features that a federated cluster must have to have a sibling job submitted to it.
	ClusterConstraint *string `json:"cluster_constraint,omitempty"`

	// Comment An arbitrary comment.
	Comment *string `json:"comment,omitempty"`

	// Constraints node features required by job.
	Constraints *string `json:"constraints,omitempty"`

	// Container absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// CoreSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	CoreSpecification *int `json:"core_specification,omitempty"`

	// CoresPerSocket Restrict node selection to nodes with at least the specified number of cores per socket.
	CoresPerSocket *int `json:"cores_per_socket,omitempty"`

	// CpuBinding Cpu binding
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingHint Cpu binding hint
	CpuBindingHint *string `json:"cpu_binding_hint,omitempty"`

	// CpuFrequency Request that job steps initiated by srun commands inside this sbatch script be run at some requested frequency if possible, on the CPUs selected for the step on the compute node(s).
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerGpu Number of CPUs requested per allocated GPU.
	CpusPerGpu *string `json:"cpus_per_gpu,omitempty"`

	// CpusPerTask Advise the Slurm controller that ensuing job steps will require ncpus number of processors per task.
	CpusPerTask *int `json:"cpus_per_task,omitempty"`

	// CurrentWorkingDirectory Instruct Slurm to connect the batch script's standard output directly to the file name.
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Remove the job if no ending is possible before this deadline (start > (deadline - time[-min])).
	Deadline *string `json:"deadline,omitempty"`

	// DelayBoot Do not reboot nodes in order to satisfied this job's feature specification if the job has been eligible to run for less than this time period.
	DelayBoot *int `json:"delay_boot,omitempty"`

	// Dependency Defer the start of this job until the specified dependencies have been satisfied completed.
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Specify alternate distribution methods for remote processes.
	Distribution *string `json:"distribution,omitempty"`

	// Environment Dictionary of environment entries.
	Environment map[string]interface{} `json:"environment"`

	// Exclusive The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
	Exclusive *V0038JobPropertiesExclusive `json:"exclusive,omitempty"`

	// GetUserEnvironment Load new login environment for user on job node.
	GetUserEnvironment *bool `json:"get_user_environment,omitempty"`

	// GpuBinding Requested binding of tasks to GPU.
	GpuBinding *string `json:"gpu_binding,omitempty"`

	// GpuFrequency Requested GPU frequency.
	GpuFrequency *string `json:"gpu_frequency,omitempty"`

	// Gpus GPUs per job.
	Gpus *string `json:"gpus,omitempty"`

	// GpusPerNode GPUs per node.
	GpusPerNode *string `json:"gpus_per_node,omitempty"`

	// GpusPerSocket GPUs per socket.
	GpusPerSocket *string `json:"gpus_per_socket,omitempty"`

	// GpusPerTask GPUs per task.
	GpusPerTask *string `json:"gpus_per_task,omitempty"`

	// Gres Specifies a comma delimited list of generic consumable resources.
	Gres *string `json:"gres,omitempty"`

	// GresFlags Specify generic resource task binding options.
	GresFlags *V0038JobPropertiesGresFlags `json:"gres_flags,omitempty"`

	// Hold Specify the job is to be submitted in a held state (priority of zero).
	Hold *bool `json:"hold,omitempty"`

	// KillOnInvalidDependency If a job has an invalid dependency, then Slurm is to terminate it.
	KillOnInvalidDependency *bool `json:"kill_on_invalid_dependency,omitempty"`

	// Licenses Specification of licenses (or other resources available on all nodes of the cluster) which must be allocated to this job.
	Licenses *string `json:"licenses,omitempty"`

	// MailType Notify user by email when certain event types occur.
	MailType *string `json:"mail_type,omitempty"`

	// MailUser User to receive email notification of state changes as defined by mail_type.
	MailUser *string `json:"mail_user,omitempty"`

	// McsLabel This parameter is a group among the groups of the user.
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Bind tasks to memory.
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryPerCpu Minimum real memory per cpu (MB).
	MemoryPerCpu *int `json:"memory_per_cpu,omitempty"`

	// MemoryPerGpu Minimum memory required per allocated GPU.
	MemoryPerGpu *int `json:"memory_per_gpu,omitempty"`

	// MemoryPerNode Minimum real memory per node (MB).
	MemoryPerNode *int `json:"memory_per_node,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node.
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes If a range of node counts is given, prefer the smaller count.
	MinimumNodes *bool `json:"minimum_nodes,omitempty"`

	// Name Specify a name for the job allocation.
	Name *string `json:"name,omitempty"`

	// Nice Run the job with an adjusted scheduling priority within Slurm.
	Nice *int `json:"nice,omitempty"`

	// NoKill Do not automatically terminate a job if one of the nodes it has been allocated fails.
	NoKill *bool `json:"no_kill,omitempty"`

	// Nodes Request that a minimum of minnodes nodes and a maximum node count.
	Nodes *[]int `json:"nodes,omitempty"`

	// OpenMode Open the output and error files using append or truncate mode as specified.
	OpenMode *V0038JobPropertiesOpenMode `json:"open_mode,omitempty"`

	// Oversubscribe The job allocation can over-subscribe resources with other running jobs.
	Oversubscribe *bool `json:"oversubscribe,omitempty"`

	// Partition Request a specific partition for the resource allocation.
	Partition *string `json:"partition,omitempty"`

	// Prefer Comma delimited list of features for scheduler to prefer but not a strict requirement like a constraint. Value can be used for job submission but is only displayed for PENDING jobs.
	Prefer *string `json:"prefer,omitempty"`

	// Priority Request a specific job priority.
	Priority *string `json:"priority,omitempty"`

	// Qos Request a quality of service for the job.
	Qos *string `json:"qos,omitempty"`

	// Requeue Specifies that the batch job should eligible to being requeue.
	Requeue *bool `json:"requeue,omitempty"`

	// Reservation Allocate resources for the job from the named reservation.
	Reservation *string `json:"reservation,omitempty"`

	// Signal When a job is within sig_time seconds of its end time, send it the signal sig_num.
	Signal *string `json:"signal,omitempty"`

	// SocketsPerNode Restrict node selection to nodes with at least the specified number of sockets.
	SocketsPerNode *int `json:"sockets_per_node,omitempty"`

	// SpreadJob Spread the job allocation over as many nodes as possible and attempt to evenly distribute tasks across the allocated nodes.
	SpreadJob *bool `json:"spread_job,omitempty"`

	// StandardError Instruct Slurm to connect the batch script's standard error directly to the file name.
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Instruct Slurm to connect the batch script's standard input directly to the file name specified.
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Instruct Slurm to connect the batch script's standard output directly to the file name.
	StandardOutput *string `json:"standard_output,omitempty"`

	// Tasks Advises the Slurm controller that job steps run within the allocation will launch a maximum of number tasks and to provide for sufficient resources.
	Tasks *int `json:"tasks,omitempty"`

	// TasksPerCore Request the maximum ntasks be invoked on each core.
	TasksPerCore *int `json:"tasks_per_core,omitempty"`

	// TasksPerNode Request the maximum ntasks be invoked on each node.
	TasksPerNode *int `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Request the maximum ntasks be invoked on each socket.
	TasksPerSocket *int `json:"tasks_per_socket,omitempty"`

	// ThreadSpecification Count of specialized threads per node reserved by the job for system operations and not used by the application.
	ThreadSpecification *int `json:"thread_specification,omitempty"`

	// ThreadsPerCore Restrict node selection to nodes with at least the specified number of threads per core.
	ThreadsPerCore *int `json:"threads_per_core,omitempty"`

	// TimeLimit Step time limit in minutes.
	TimeLimit *int `json:"time_limit,omitempty"`

	// TimeMinimum Minimum run time in minutes.
	TimeMinimum *int `json:"time_minimum,omitempty"`

	// WaitAllNodes Do not begin execution until all nodes are ready for use.
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// Wckey Specify wckey to be used with job.
	Wckey *string `json:"wckey,omitempty"`
}

// V0038JobPropertiesExclusive The job allocation can share nodes just other users with the "user" option or with the "mcs" option).
type V0038JobPropertiesExclusive string

// V0038JobPropertiesGresFlags Specify generic resource task binding options.
type V0038JobPropertiesGresFlags string

// V0038JobPropertiesOpenMode Open the output and error files using append or truncate mode as specified.
type V0038JobPropertiesOpenMode string

// V0038JobResources defines model for v0.0.38_job_resources.
type V0038JobResources struct {
	// AllocatedCpus number of assigned job cpus
	AllocatedCpus *int `json:"allocated_cpus,omitempty"`

	// AllocatedHosts number of assigned job hosts
	AllocatedHosts *int `json:"allocated_hosts,omitempty"`

	// AllocatedNodes array of allocated nodes
	AllocatedNodes *[]V0038NodeAllocation `json:"allocated_nodes,omitempty"`

	// Nodes list of assigned job nodes
	Nodes *string `json:"nodes,omitempty"`
}

// V0038JobResponseProperties defines model for v0.0.38_job_response_properties.
type V0038JobResponseProperties struct {
	// Account Charge resources used by this job to specified account
	Account *string `json:"account,omitempty"`

	// AccrueTime time job is eligible for running
	AccrueTime *int64 `json:"accrue_time,omitempty"`

	// AdminComment administrator's arbitrary comment
	AdminComment *string `json:"admin_comment,omitempty"`

	// ArrayJobId job_id of a job array or 0 if N/A
	ArrayJobId *int `json:"array_job_id,omitempty"`

	// ArrayMaxTasks Maximum number of running array tasks
	ArrayMaxTasks *int `json:"array_max_tasks,omitempty"`

	// ArrayTaskId task_id of a job array
	ArrayTaskId *int `json:"array_task_id,omitempty"`

	// ArrayTaskString string expression of task IDs in this record
	ArrayTaskString *string `json:"array_task_string,omitempty"`

	// AssociationId association id for job
	AssociationId *int `json:"association_id,omitempty"`

	// BatchFeatures features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BatchFlag if batch: queued job with script
	BatchFlag *bool `json:"batch_flag,omitempty"`

	// BatchHost name of host running batch script
	BatchHost *string `json:"batch_host,omitempty"`

	// BillableTres billable TRES
	BillableTres *float32 `json:"billable_tres,omitempty"`

	// BurstBuffer burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// BurstBufferState burst buffer state info
	BurstBufferState *string `json:"burst_buffer_state,omitempty"`

	// Cluster name of cluster that the job is on
	Cluster *string `json:"cluster,omitempty"`

	// ClusterFeatures comma separated list of required cluster features
	ClusterFeatures *string `json:"cluster_features,omitempty"`

	// Command command to be executed
	Command *string `json:"command,omitempty"`

	// Comment arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Container absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// Contiguous job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpec specialized core count
	CoreSpec *string `json:"core_spec,omitempty"`

	// CoresPerSocket cores per socket required by job
	CoresPerSocket *string `json:"cores_per_socket,omitempty"`

	// CpuFrequencyGovernor cpu frequency governor
	CpuFrequencyGovernor *string `json:"cpu_frequency_governor,omitempty"`

	// CpuFrequencyMaximum Maximum cpu frequency
	CpuFrequencyMaximum *string `json:"cpu_frequency_maximum,omitempty"`

	// CpuFrequencyMinimum Minimum cpu frequency
	CpuFrequencyMinimum *string `json:"cpu_frequency_minimum,omitempty"`

	// Cpus minimum number of cpus required by job
	Cpus *int `json:"cpus,omitempty"`

	// CpusPerTask number of processors required for each task
	CpusPerTask *string `json:"cpus_per_task,omitempty"`

	// CpusPerTres semicolon delimited list of TRES=# values
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// CurrentWorkingDirectory pathname of working directory
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline job start deadline
	Deadline *int `json:"deadline,omitempty"`

	// DelayBoot command to be executed
	DelayBoot *int `json:"delay_boot,omitempty"`

	// Dependency synchronize job execution with other jobs
	Dependency *string `json:"dependency,omitempty"`

	// DerivedExitCode highest exit code of all job steps
	DerivedExitCode *int `json:"derived_exit_code,omitempty"`

	// EligibleTime time job is eligible for running
	EligibleTime *int64 `json:"eligible_time,omitempty"`

	// EndTime time of termination, actual or expected
	EndTime *int64 `json:"end_time,omitempty"`

	// ExcludedNodes comma separated list of excluded nodes
	ExcludedNodes *string `json:"excluded_nodes,omitempty"`

	// ExitCode exit code for job
	ExitCode *int `json:"exit_code,omitempty"`

	// Features comma separated list of required features
	Features *string `json:"features,omitempty"`

	// FederationOrigin Origin cluster's name
	FederationOrigin *string `json:"federation_origin,omitempty"`

	// FederationSiblingsActive string of active sibling names
	FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

	// FederationSiblingsViable string of viable sibling names
	FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

	// Flags Job flags
	Flags *[]string `json:"flags,omitempty"`

	// GresDetail Job flags
	GresDetail *[]string `json:"gres_detail,omitempty"`

	// GroupId group job submitted as
	GroupId *int `json:"group_id,omitempty"`

	// HetJobId job ID of hetjob leader
	HetJobId *int `json:"het_job_id,omitempty"`

	// HetJobIdSet job IDs for all components
	HetJobIdSet *string `json:"het_job_id_set,omitempty"`

	// HetJobOffset HetJob component offset from leader
	HetJobOffset *int `json:"het_job_offset,omitempty"`

	// JobId job ID
	JobId        *int               `json:"job_id,omitempty"`
	JobResources *V0038JobResources `json:"job_resources,omitempty"`

	// JobState state of the job
	JobState *string `json:"job_state,omitempty"`

	// LastSchedEvaluation last time job was evaluated for scheduling
	LastSchedEvaluation *int `json:"last_sched_evaluation,omitempty"`

	// Licenses licenses required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MaxCpus maximum number of cpus usable by job
	MaxCpus *int `json:"max_cpus,omitempty"`

	// MaxNodes maximum number of nodes usable by job
	MaxNodes *int `json:"max_nodes,omitempty"`

	// McsLabel mcs_label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryPerCpu minimum real memory per cpu
	MemoryPerCpu *int `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode minimum real memory per node
	MemoryPerNode *int `json:"memory_per_node,omitempty"`

	// MemoryPerTres semicolon delimited list of TRES=# values
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumCpusPerNode minimum # CPUs per node
	MinimumCpusPerNode *int `json:"minimum_cpus_per_node,omitempty"`

	// MinimumTmpDiskPerNode minimum tmp disk per node
	MinimumTmpDiskPerNode *int `json:"minimum_tmp_disk_per_node,omitempty"`

	// Name name of the job
	Name *string `json:"name,omitempty"`

	// Nice requested priority change
	Nice *int `json:"nice,omitempty"`

	// NodeCount minimum number of nodes required by job
	NodeCount *int `json:"node_count,omitempty"`

	// Nodes list of nodes allocated to job
	Nodes *string `json:"nodes,omitempty"`

	// Partition name of assigned partition
	Partition *string `json:"partition,omitempty"`

	// PreSusTime time job ran prior to last suspend
	PreSusTime *int64 `json:"pre_sus_time,omitempty"`

	// PreemptTime preemption signal time
	PreemptTime *int64 `json:"preempt_time,omitempty"`

	// Priority relative priority of the job
	Priority *int `json:"priority,omitempty"`

	// Profile Job profiling requested
	Profile *[]string `json:"profile,omitempty"`

	// Qos Quality of Service
	Qos *string `json:"qos,omitempty"`

	// Reboot node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue enable or disable job requeue option
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes comma separated list of required nodes
	RequiredNodes *string `json:"required_nodes,omitempty"`

	// ResizeTime time of latest size change
	ResizeTime *int64 `json:"resize_time,omitempty"`

	// RestartCnt count of job restarts
	RestartCnt *int `json:"restart_cnt,omitempty"`

	// ResvName reservation name
	ResvName *string `json:"resv_name,omitempty"`

	// Shared type and if job can share nodes with other jobs
	Shared *string `json:"shared,omitempty"`

	// ShowFlags details requested
	ShowFlags *[]string `json:"show_flags,omitempty"`

	// SocketsPerBoard sockets per board required by job
	SocketsPerBoard *int `json:"sockets_per_board,omitempty"`

	// SocketsPerNode sockets per node required by job
	SocketsPerNode *int `json:"sockets_per_node,omitempty"`

	// StandardError pathname of job's stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput pathname of job's stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput pathname of job's stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// StartTime time execution begins, actual or expected
	StartTime *int64 `json:"start_time,omitempty"`

	// StateDescription optional details for state_reason
	StateDescription *string `json:"state_description,omitempty"`

	// StateReason reason job still pending or failed
	StateReason *string `json:"state_reason,omitempty"`

	// SubmitTime time of job submission
	SubmitTime *int64 `json:"submit_time,omitempty"`

	// SuspendTime time job last suspended or resumed
	SuspendTime *int64 `json:"suspend_time,omitempty"`

	// SystemComment slurmctld's arbitrary comment
	SystemComment *string `json:"system_comment,omitempty"`

	// Tasks requested task count
	Tasks *int `json:"tasks,omitempty"`

	// TasksPerBoard number of tasks to invoke on each board
	TasksPerBoard *int `json:"tasks_per_board,omitempty"`

	// TasksPerCore number of tasks to invoke on each core
	TasksPerCore *int `json:"tasks_per_core,omitempty"`

	// TasksPerSocket number of tasks to invoke on each socket
	TasksPerSocket *int `json:"tasks_per_socket,omitempty"`

	// ThreadSpec specialized thread count
	ThreadSpec *string `json:"thread_spec,omitempty"`

	// ThreadsPerCore threads per core required by job
	ThreadsPerCore *int `json:"threads_per_core,omitempty"`

	// TimeLimit maximum run time in minutes
	TimeLimit *int64 `json:"time_limit,omitempty"`

	// TimeMinimum minimum run time in minutes
	TimeMinimum *int64 `json:"time_minimum,omitempty"`

	// TresAllocStr tres used in the job
	TresAllocStr *string `json:"tres_alloc_str,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob semicolon delimited list of TRES=# values
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode semicolon delimited list of TRES=# values
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket semicolon delimited list of TRES=# values
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask semicolon delimited list of TRES=# values
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// TresReqStr tres reqeusted in the job
	TresReqStr *string `json:"tres_req_str,omitempty"`

	// UserId user id the job runs as
	UserId *int64 `json:"user_id,omitempty"`

	// UserName user the job runs as
	UserName *string `json:"user_name,omitempty"`

	// Wckey wckey for job
	Wckey *string `json:"wckey,omitempty"`
}

// V0038JobSubmission defines model for v0.0.38_job_submission.
type V0038JobSubmission struct {
	Job *V0038JobProperties `json:"job,omitempty"`

	// Jobs Properties of an HetJob
	Jobs *[]V0038JobProperties `json:"jobs,omitempty"`

	// Script Executable script (full contents) to run in batch step
	Script string `json:"script"`
}

// V0038JobSubmissionResponse defines model for v0.0.38_job_submission_response.
type V0038JobSubmissionResponse struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`

	// JobId new job ID
	JobId *int `json:"job_id,omitempty"`

	// JobSubmitUserMsg Message to user from job_submit plugin
	JobSubmitUserMsg *string    `json:"job_submit_user_msg,omitempty"`
	Meta             *V0038Meta `json:"meta,omitempty"`

	// StepId new job step ID
	StepId *string `json:"step_id,omitempty"`
}

// V0038JobsResponse defines model for v0.0.38_jobs_response.
type V0038JobsResponse struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`

	// Jobs job descriptions
	Jobs *[]V0038JobResponseProperties `json:"jobs,omitempty"`
	Meta *V0038Meta                    `json:"meta,omitempty"`
}

// V0038License defines model for v0.0.38_license.
type V0038License struct {
	// Free number of licenses available
	Free *int `json:"Free,omitempty"`

	// LicenseName name of license
	LicenseName *string `json:"LicenseName,omitempty"`

	// Remote license is remote
	Remote *bool `json:"Remote,omitempty"`

	// Reserved number of licenses reserved
	Reserved *int `json:"Reserved,omitempty"`

	// Total total number of licenses
	Total *int `json:"Total,omitempty"`

	// Used number of licenses in use
	Used *int `json:"Used,omitempty"`
}

// V0038Licenses defines model for v0.0.38_licenses.
type V0038Licenses struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`

	// Licenses licenses info
	Licenses *[]V0038License `json:"licenses,omitempty"`
}

// V0038Meta defines model for v0.0.38_meta.
type V0038Meta struct {
	// Slurm Slurm information
	Slurm *struct {
		// Release version specifier
		Release *string `json:"release,omitempty"`
		Version *struct {
			Major *int `json:"major,omitempty"`
			Micro *int `json:"micro,omitempty"`
			Minor *int `json:"minor,omitempty"`
		} `json:"version,omitempty"`
	} `json:"Slurm,omitempty"`
	Plugin *struct {
		Name *string `json:"name,omitempty"`
		Type *string `json:"type,omitempty"`
	} `json:"plugin,omitempty"`
}

// V0038Node defines model for v0.0.38_node.
type V0038Node struct {
	// ActiveFeatures list of a node's available features
	ActiveFeatures *string `json:"active_features,omitempty"`

	// Address state after reboot
	Address *string `json:"address,omitempty"`

	// AllocCpus Allocated CPUs
	AllocCpus *int64 `json:"alloc_cpus,omitempty"`

	// AllocMemory Allocated memory (MB)
	AllocMemory *int64 `json:"alloc_memory,omitempty"`

	// Architecture computer architecture
	Architecture *string `json:"architecture,omitempty"`

	// Boards total number of boards per node
	Boards *int `json:"boards,omitempty"`

	// BootTime timestamp of node boot
	BootTime *int64 `json:"boot_time,omitempty"`

	// BurstbufferNetworkAddress BcastAddr
	BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

	// Cores number of cores per socket
	Cores *int `json:"cores,omitempty"`

	// CpuBinding Default task binding
	CpuBinding *int `json:"cpu_binding,omitempty"`

	// CpuLoad CPU load * 100
	CpuLoad *int64 `json:"cpu_load,omitempty"`

	// Cpus configured count of cpus running on the node
	Cpus     *int    `json:"cpus,omitempty"`
	Features *string `json:"features,omitempty"`

	// FreeMemory free memory in MiB
	FreeMemory *int `json:"free_memory,omitempty"`

	// Gres list of a node's generic resources
	Gres *string `json:"gres,omitempty"`

	// GresDrained list of drained GRES
	GresDrained *string `json:"gres_drained,omitempty"`

	// GresUsed list of GRES in current use
	GresUsed *string `json:"gres_used,omitempty"`

	// Hostname node's hostname
	Hostname *string `json:"hostname,omitempty"`

	// IdleCpus Idle CPUs
	IdleCpus *int64 `json:"idle_cpus,omitempty"`

	// McsLabel mcs label if mcs plugin in use
	McsLabel *string `json:"mcs_label,omitempty"`

	// Name node name to slurm
	Name *string `json:"name,omitempty"`

	// NextStateAfterReboot state after reboot
	NextStateAfterReboot *string `json:"next_state_after_reboot,omitempty"`

	// NextStateAfterRebootFlags node state flags
	NextStateAfterRebootFlags *[]string `json:"next_state_after_reboot_flags,omitempty"`

	// OperatingSystem operating system
	OperatingSystem *string `json:"operating_system,omitempty"`

	// Owner User allowed to use this node
	Owner *string `json:"owner,omitempty"`

	// Partitions assigned partitions
	Partitions *[]string `json:"partitions,omitempty"`

	// Port TCP port number of the slurmd
	Port *int `json:"port,omitempty"`

	// RealMemory configured MB of real memory on the node
	RealMemory *int `json:"real_memory,omitempty"`

	// Reason reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonChangedAt Time stamp when reason was set
	ReasonChangedAt *int `json:"reason_changed_at,omitempty"`

	// ReasonSetByUser User that set the reason
	ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

	// SlurmdStartTime timestamp of slurmd startup
	SlurmdStartTime *int64 `json:"slurmd_start_time,omitempty"`

	// SlurmdVersion Slurmd version
	SlurmdVersion *string `json:"slurmd_version,omitempty"`

	// Sockets total number of sockets per node
	Sockets *int `json:"sockets,omitempty"`

	// State current node state
	State *string `json:"state,omitempty"`

	// StateFlags node state flags
	StateFlags *[]string `json:"state_flags,omitempty"`

	// TemporaryDisk configured MB of total disk in TMP_FS
	TemporaryDisk *int `json:"temporary_disk,omitempty"`

	// Threads number of threads per core
	Threads *int `json:"threads,omitempty"`

	// Tres TRES on node
	Tres *string `json:"tres,omitempty"`

	// TresUsed TRES used on node
	TresUsed *string `json:"tres_used,omitempty"`

	// TresWeighted TRES weight used on node
	TresWeighted *float64 `json:"tres_weighted,omitempty"`

	// Weight arbitrary priority of node for scheduling
	Weight *int `json:"weight,omitempty"`
}

// V0038NodeAllocation defines model for v0.0.38_node_allocation.
type V0038NodeAllocation struct {
	// Cpus number of assigned job CPUs
	Cpus *int `json:"cpus,omitempty"`

	// Memory amount of assigned job memory
	Memory *int `json:"memory,omitempty"`

	// Nodename node name
	Nodename *string `json:"nodename,omitempty"`

	// Sockets assignment status of each socket by numeric socket id
	Sockets *struct {
		// Cores assignment status of each core by core id in each socket
		Cores *map[string]interface{} `json:"cores,omitempty"`
	} `json:"sockets,omitempty"`
}

// V0038NodesResponse defines model for v0.0.38_nodes_response.
type V0038NodesResponse struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`
	Meta   *V0038Meta    `json:"meta,omitempty"`

	// Nodes nodes info
	Nodes *[]V0038Node `json:"nodes,omitempty"`
}

// V0038Partition defines model for v0.0.38_partition.
type V0038Partition struct {
	// AllowedAccounts comma delimited list of accounts
	AllowedAccounts *string `json:"allowed_accounts,omitempty"`

	// AllowedAllocationNodes list names of allowed allocating nodes
	AllowedAllocationNodes *string `json:"allowed_allocation_nodes,omitempty"`

	// AllowedGroups comma delimited list of groups
	AllowedGroups *string `json:"allowed_groups,omitempty"`

	// AllowedQos comma delimited list of qos
	AllowedQos *string `json:"allowed_qos,omitempty"`

	// Alternative name of alternate partition
	Alternative *string `json:"alternative,omitempty"`

	// BillingWeights TRES billing weights
	BillingWeights *string `json:"billing_weights,omitempty"`

	// DefaultMemoryPerCpu default MB memory per allocated CPU
	DefaultMemoryPerCpu *int64 `json:"default_memory_per_cpu,omitempty"`

	// DefaultMemoryPerNode default MB memory per allocated node
	DefaultMemoryPerNode *int64 `json:"default_memory_per_node,omitempty"`

	// DefaultTimeLimit default time limit (minutes)
	DefaultTimeLimit *int64 `json:"default_time_limit,omitempty"`

	// DeniedAccounts comma delimited list of denied accounts
	DeniedAccounts *string `json:"denied_accounts,omitempty"`

	// DeniedQos comma delimited list of denied qos
	DeniedQos *string `json:"denied_qos,omitempty"`

	// Flags partition options
	Flags *[]string `json:"flags,omitempty"`

	// MaxTimeLimit Max time limit per job
	MaxTimeLimit *int64 `json:"max_time_limit,omitempty"`

	// MaximumCpusPerNode maximum allocated CPUs per node
	MaximumCpusPerNode *int `json:"maximum_cpus_per_node,omitempty"`

	// MaximumMemoryPerCpu maximum memory per allocated CPU (MiB)
	MaximumMemoryPerCpu *int64 `json:"maximum_memory_per_cpu,omitempty"`

	// MaximumMemoryPerNode maximum memory per allocated node (MiB)
	MaximumMemoryPerNode *int64 `json:"maximum_memory_per_node,omitempty"`

	// MaximumNodesPerJob Max nodes per job
	MaximumNodesPerJob *int `json:"maximum_nodes_per_job,omitempty"`

	// MinNodesPerJob Min number of nodes per job
	MinNodesPerJob *int `json:"min_nodes_per_job,omitempty"`

	// Name Partition name
	Name *string `json:"name,omitempty"`

	// Nodes list names of nodes in partition
	Nodes *string `json:"nodes,omitempty"`

	// OverTimeLimit job's time limit can be exceeded by this number of minutes before cancellation
	OverTimeLimit *int `json:"over_time_limit,omitempty"`

	// PreemptionGraceTime preemption grace time (seconds)
	PreemptionGraceTime *int64 `json:"preemption_grace_time,omitempty"`

	// PreemptionMode preemption type
	PreemptionMode *[]string `json:"preemption_mode,omitempty"`

	// PriorityJobFactor job priority weight factor
	PriorityJobFactor *int `json:"priority_job_factor,omitempty"`

	// PriorityTier tier for scheduling and preemption
	PriorityTier *int `json:"priority_tier,omitempty"`

	// Qos partition QOS name
	Qos *string `json:"qos,omitempty"`

	// State Partition state
	State *string `json:"state,omitempty"`

	// TotalCpus Total cpus in partition
	TotalCpus *int `json:"total_cpus,omitempty"`

	// TotalNodes Total number of nodes in partition
	TotalNodes *int `json:"total_nodes,omitempty"`

	// Tres configured TRES in partition
	Tres *string `json:"tres,omitempty"`
}

// V0038PartitionsResponse defines model for v0.0.38_partitions_response.
type V0038PartitionsResponse struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`
	Meta   *V0038Meta    `json:"meta,omitempty"`

	// Partitions partition info
	Partitions *[]V0038Partition `json:"partitions,omitempty"`
}

// V0038Ping defines model for v0.0.38_ping.
type V0038Ping struct {
	// Hostname slurm controller hostname
	Hostname *string `json:"hostname,omitempty"`

	// Mode slurm controller mode
	Mode *string `json:"mode,omitempty"`

	// Ping slurm controller host up
	Ping *V0038PingPing `json:"ping,omitempty"`

	// Status slurm controller status
	Status *int `json:"status,omitempty"`
}

// V0038PingPing slurm controller host up
type V0038PingPing string

// V0038Pings defines model for v0.0.38_pings.
type V0038Pings struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`
	Meta   *V0038Meta    `json:"meta,omitempty"`

	// Pings slurm controller pings
	Pings *[]V0038Ping `json:"pings,omitempty"`
}

// V0038Reservation defines model for v0.0.38_reservation.
type V0038Reservation struct {
	// Accounts Allowed accounts
	Accounts *string `json:"accounts,omitempty"`

	// BurstBuffer Reserved burst buffer
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// CoreCount Number of reserved cores
	CoreCount *int `json:"core_count,omitempty"`

	// CoreSpecCnt Number of reserved specialized cores
	CoreSpecCnt *int `json:"core_spec_cnt,omitempty"`

	// EndTime End time of the reservation
	EndTime *int `json:"end_time,omitempty"`

	// Features List of features
	Features *string `json:"features,omitempty"`

	// Flags Reservation options
	Flags *[]string `json:"flags,omitempty"`

	// Groups List of groups permitted to use the reserved nodes
	Groups *string `json:"groups,omitempty"`

	// Licenses List of licenses
	Licenses *string `json:"licenses,omitempty"`

	// MaxStartDelay Maximum delay in which jobs outside of the reservation will be permitted to overlap once any jobs are queued for the reservation
	MaxStartDelay *int `json:"max_start_delay,omitempty"`

	// Name Reservationn name
	Name *string `json:"name,omitempty"`

	// NodeCount Count of nodes reserved
	NodeCount *int `json:"node_count,omitempty"`

	// NodeList List of reserved nodes
	NodeList *string `json:"node_list,omitempty"`

	// Partition Partition
	Partition *string `json:"partition,omitempty"`

	// PurgeCompleted If PURGE_COMP flag is set the amount of seconds this reservation will sit idle until it is revoked
	PurgeCompleted *struct {
		// Time amount of seconds this reservation will sit idle until it is revoked
		Time *int `json:"time,omitempty"`
	} `json:"purge_completed,omitempty"`

	// StartTime Start time of reservation
	StartTime *int `json:"start_time,omitempty"`

	// Tres List of TRES
	Tres *string `json:"tres,omitempty"`

	// Users List of users
	Users *string `json:"users,omitempty"`

	// Watts amount of power to reserve in watts
	Watts *int `json:"watts,omitempty"`
}

// V0038ReservationsResponse defines model for v0.0.38_reservations_response.
type V0038ReservationsResponse struct {
	// Errors slurm errors
	Errors *[]V0038Error `json:"errors,omitempty"`
	Meta   *V0038Meta    `json:"meta,omitempty"`

	// Reservations reservation info
	Reservations *[]V0038Reservation `json:"reservations,omitempty"`
}

// V0038Signal POSIX signal name
type V0038Signal string

// SlurmV0038CancelJobParams defines parameters for SlurmV0038CancelJob.
type SlurmV0038CancelJobParams struct {
	// Signal signal to send to job
	Signal *V0038Signal `form:"signal,omitempty" json:"signal,omitempty"`
}

// SlurmV0038GetJobsParams defines parameters for SlurmV0038GetJobs.
type SlurmV0038GetJobsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0038GetNodesParams defines parameters for SlurmV0038GetNodes.
type SlurmV0038GetNodesParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0038GetPartitionParams defines parameters for SlurmV0038GetPartition.
type SlurmV0038GetPartitionParams struct {
	// UpdateTime Filter if there were no partition changes (not limited to partition in URL endpoint) since update_time.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0038GetPartitionsParams defines parameters for SlurmV0038GetPartitions.
type SlurmV0038GetPartitionsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0038GetReservationParams defines parameters for SlurmV0038GetReservation.
type SlurmV0038GetReservationParams struct {
	// UpdateTime Filter if no reservation (not limited to reservation in URL) changed since update_time.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0038GetReservationsParams defines parameters for SlurmV0038GetReservations.
type SlurmV0038GetReservationsParams struct {
	// UpdateTime Filter if changed since update_time. Use of this parameter can result in faster replies.
	UpdateTime *int64 `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0038SubmitJobJSONRequestBody defines body for SlurmV0038SubmitJob for application/json ContentType.
type SlurmV0038SubmitJobJSONRequestBody = V0038JobSubmission

// SlurmV0038UpdateJobJSONRequestBody defines body for SlurmV0038UpdateJob for application/json ContentType.
type SlurmV0038UpdateJobJSONRequestBody = V0038JobProperties

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOpenapi request
	GetOpenapi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiJson request
	GetOpenapiJson(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiYaml request
	GetOpenapiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiV3 request
	GetOpenapiV3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038Diag request
	SlurmV0038Diag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038SubmitJobWithBody request with any body
	SlurmV0038SubmitJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0038SubmitJob(ctx context.Context, body SlurmV0038SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038CancelJob request
	SlurmV0038CancelJob(ctx context.Context, jobId string, params *SlurmV0038CancelJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetJob request
	SlurmV0038GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038UpdateJobWithBody request with any body
	SlurmV0038UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0038UpdateJob(ctx context.Context, jobId string, body SlurmV0038UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetJobs request
	SlurmV0038GetJobs(ctx context.Context, params *SlurmV0038GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038SlurmctldGetLicenses request
	SlurmV0038SlurmctldGetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetNode request
	SlurmV0038GetNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetNodes request
	SlurmV0038GetNodes(ctx context.Context, params *SlurmV0038GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetPartition request
	SlurmV0038GetPartition(ctx context.Context, partitionName string, params *SlurmV0038GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetPartitions request
	SlurmV0038GetPartitions(ctx context.Context, params *SlurmV0038GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038Ping request
	SlurmV0038Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetReservation request
	SlurmV0038GetReservation(ctx context.Context, reservationName string, params *SlurmV0038GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0038GetReservations request
	SlurmV0038GetReservations(ctx context.Context, params *SlurmV0038GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOpenapi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiJson(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiJsonRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiYaml(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiYamlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiV3(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiV3Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038Diag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038DiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038SubmitJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038SubmitJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038SubmitJob(ctx context.Context, body SlurmV0038SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038SubmitJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038CancelJob(ctx context.Context, jobId string, params *SlurmV0038CancelJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038CancelJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038UpdateJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038UpdateJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038UpdateJob(ctx context.Context, jobId string, body SlurmV0038UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038UpdateJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetJobs(ctx context.Context, params *SlurmV0038GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038SlurmctldGetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038SlurmctldGetLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetNodes(ctx context.Context, params *SlurmV0038GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetPartition(ctx context.Context, partitionName string, params *SlurmV0038GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetPartitions(ctx context.Context, params *SlurmV0038GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038Ping(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038PingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetReservation(ctx context.Context, reservationName string, params *SlurmV0038GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0038GetReservations(ctx context.Context, params *SlurmV0038GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0038GetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOpenapiRequest generates requests for GetOpenapi
func NewGetOpenapiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiJsonRequest generates requests for GetOpenapiJson
func NewGetOpenapiJsonRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiYamlRequest generates requests for GetOpenapiYaml
func NewGetOpenapiYamlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi.yaml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiV3Request generates requests for GetOpenapiV3
func NewGetOpenapiV3Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/openapi/v3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038DiagRequest generates requests for SlurmV0038Diag
func NewSlurmV0038DiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/diag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038SubmitJobRequest calls the generic SlurmV0038SubmitJob builder with application/json body
func NewSlurmV0038SubmitJobRequest(server string, body SlurmV0038SubmitJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0038SubmitJobRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0038SubmitJobRequestWithBody generates requests for SlurmV0038SubmitJob with any type of body
func NewSlurmV0038SubmitJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0038CancelJobRequest generates requests for SlurmV0038CancelJob
func NewSlurmV0038CancelJobRequest(server string, jobId string, params *SlurmV0038CancelJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038GetJobRequest generates requests for SlurmV0038GetJob
func NewSlurmV0038GetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038UpdateJobRequest calls the generic SlurmV0038UpdateJob builder with application/json body
func NewSlurmV0038UpdateJobRequest(server string, jobId string, body SlurmV0038UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0038UpdateJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmV0038UpdateJobRequestWithBody generates requests for SlurmV0038UpdateJob with any type of body
func NewSlurmV0038UpdateJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0038GetJobsRequest generates requests for SlurmV0038GetJobs
func NewSlurmV0038GetJobsRequest(server string, params *SlurmV0038GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038SlurmctldGetLicensesRequest generates requests for SlurmV0038SlurmctldGetLicenses
func NewSlurmV0038SlurmctldGetLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/licenses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038GetNodeRequest generates requests for SlurmV0038GetNode
func NewSlurmV0038GetNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038GetNodesRequest generates requests for SlurmV0038GetNodes
func NewSlurmV0038GetNodesRequest(server string, params *SlurmV0038GetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038GetPartitionRequest generates requests for SlurmV0038GetPartition
func NewSlurmV0038GetPartitionRequest(server string, partitionName string, params *SlurmV0038GetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038GetPartitionsRequest generates requests for SlurmV0038GetPartitions
func NewSlurmV0038GetPartitionsRequest(server string, params *SlurmV0038GetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/partitions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038PingRequest generates requests for SlurmV0038Ping
func NewSlurmV0038PingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038GetReservationRequest generates requests for SlurmV0038GetReservation
func NewSlurmV0038GetReservationRequest(server string, reservationName string, params *SlurmV0038GetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0038GetReservationsRequest generates requests for SlurmV0038GetReservations
func NewSlurmV0038GetReservationsRequest(server string, params *SlurmV0038GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.38/reservations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOpenapiWithResponse request
	GetOpenapiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiResponse, error)

	// GetOpenapiJsonWithResponse request
	GetOpenapiJsonWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiJsonResponse, error)

	// GetOpenapiYamlWithResponse request
	GetOpenapiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiYamlResponse, error)

	// GetOpenapiV3WithResponse request
	GetOpenapiV3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiV3Response, error)

	// SlurmV0038DiagWithResponse request
	SlurmV0038DiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0038DiagResponse, error)

	// SlurmV0038SubmitJobWithBodyWithResponse request with any body
	SlurmV0038SubmitJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0038SubmitJobResponse, error)

	SlurmV0038SubmitJobWithResponse(ctx context.Context, body SlurmV0038SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0038SubmitJobResponse, error)

	// SlurmV0038CancelJobWithResponse request
	SlurmV0038CancelJobWithResponse(ctx context.Context, jobId string, params *SlurmV0038CancelJobParams, reqEditors ...RequestEditorFn) (*SlurmV0038CancelJobResponse, error)

	// SlurmV0038GetJobWithResponse request
	SlurmV0038GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmV0038GetJobResponse, error)

	// SlurmV0038UpdateJobWithBodyWithResponse request with any body
	SlurmV0038UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0038UpdateJobResponse, error)

	SlurmV0038UpdateJobWithResponse(ctx context.Context, jobId string, body SlurmV0038UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0038UpdateJobResponse, error)

	// SlurmV0038GetJobsWithResponse request
	SlurmV0038GetJobsWithResponse(ctx context.Context, params *SlurmV0038GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetJobsResponse, error)

	// SlurmV0038SlurmctldGetLicensesWithResponse request
	SlurmV0038SlurmctldGetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0038SlurmctldGetLicensesResponse, error)

	// SlurmV0038GetNodeWithResponse request
	SlurmV0038GetNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0038GetNodeResponse, error)

	// SlurmV0038GetNodesWithResponse request
	SlurmV0038GetNodesWithResponse(ctx context.Context, params *SlurmV0038GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetNodesResponse, error)

	// SlurmV0038GetPartitionWithResponse request
	SlurmV0038GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0038GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetPartitionResponse, error)

	// SlurmV0038GetPartitionsWithResponse request
	SlurmV0038GetPartitionsWithResponse(ctx context.Context, params *SlurmV0038GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetPartitionsResponse, error)

	// SlurmV0038PingWithResponse request
	SlurmV0038PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0038PingResponse, error)

	// SlurmV0038GetReservationWithResponse request
	SlurmV0038GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0038GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetReservationResponse, error)

	// SlurmV0038GetReservationsWithResponse request
	SlurmV0038GetReservationsWithResponse(ctx context.Context, params *SlurmV0038GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetReservationsResponse, error)
}

type GetOpenapiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiJsonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiJsonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiJsonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiYamlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiYamlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiYamlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiV3Response struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetOpenapiV3Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiV3Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038DiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038Diag
	YAML200      *V0038Diag
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038DiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038DiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038SubmitJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038JobSubmissionResponse
	YAML200      *V0038JobSubmissionResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038SubmitJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038SubmitJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038CancelJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SlurmV0038CancelJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038CancelJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038JobsResponse
	YAML200      *V0038JobsResponse
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038UpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SlurmV0038UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038JobsResponse
	YAML200      *V0038JobsResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038SlurmctldGetLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038Licenses
	YAML200      *V0038Licenses
}

// Status returns HTTPResponse.Status
func (r SlurmV0038SlurmctldGetLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038SlurmctldGetLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038NodesResponse
	YAML200      *V0038NodesResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038NodesResponse
	YAML200      *V0038NodesResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038PartitionsResponse
	YAML200      *V0038PartitionsResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038PartitionsResponse
	YAML200      *V0038PartitionsResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038PingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038Pings
	YAML200      *V0038Pings
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038PingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038PingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038ReservationsResponse
	YAML200      *V0038ReservationsResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0038GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0038ReservationsResponse
	YAML200      *V0038ReservationsResponse
	JSONDefault  *V0038Errors
	YAMLDefault  *V0038Errors
}

// Status returns HTTPResponse.Status
func (r SlurmV0038GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0038GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOpenapiWithResponse request returning *GetOpenapiResponse
func (c *ClientWithResponses) GetOpenapiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiResponse, error) {
	rsp, err := c.GetOpenapi(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiResponse(rsp)
}

// GetOpenapiJsonWithResponse request returning *GetOpenapiJsonResponse
func (c *ClientWithResponses) GetOpenapiJsonWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiJsonResponse, error) {
	rsp, err := c.GetOpenapiJson(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiJsonResponse(rsp)
}

// GetOpenapiYamlWithResponse request returning *GetOpenapiYamlResponse
func (c *ClientWithResponses) GetOpenapiYamlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiYamlResponse, error) {
	rsp, err := c.GetOpenapiYaml(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiYamlResponse(rsp)
}

// GetOpenapiV3WithResponse request returning *GetOpenapiV3Response
func (c *ClientWithResponses) GetOpenapiV3WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiV3Response, error) {
	rsp, err := c.GetOpenapiV3(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiV3Response(rsp)
}

// SlurmV0038DiagWithResponse request returning *SlurmV0038DiagResponse
func (c *ClientWithResponses) SlurmV0038DiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0038DiagResponse, error) {
	rsp, err := c.SlurmV0038Diag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038DiagResponse(rsp)
}

// SlurmV0038SubmitJobWithBodyWithResponse request with arbitrary body returning *SlurmV0038SubmitJobResponse
func (c *ClientWithResponses) SlurmV0038SubmitJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0038SubmitJobResponse, error) {
	rsp, err := c.SlurmV0038SubmitJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038SubmitJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0038SubmitJobWithResponse(ctx context.Context, body SlurmV0038SubmitJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0038SubmitJobResponse, error) {
	rsp, err := c.SlurmV0038SubmitJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038SubmitJobResponse(rsp)
}

// SlurmV0038CancelJobWithResponse request returning *SlurmV0038CancelJobResponse
func (c *ClientWithResponses) SlurmV0038CancelJobWithResponse(ctx context.Context, jobId string, params *SlurmV0038CancelJobParams, reqEditors ...RequestEditorFn) (*SlurmV0038CancelJobResponse, error) {
	rsp, err := c.SlurmV0038CancelJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038CancelJobResponse(rsp)
}

// SlurmV0038GetJobWithResponse request returning *SlurmV0038GetJobResponse
func (c *ClientWithResponses) SlurmV0038GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmV0038GetJobResponse, error) {
	rsp, err := c.SlurmV0038GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetJobResponse(rsp)
}

// SlurmV0038UpdateJobWithBodyWithResponse request with arbitrary body returning *SlurmV0038UpdateJobResponse
func (c *ClientWithResponses) SlurmV0038UpdateJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0038UpdateJobResponse, error) {
	rsp, err := c.SlurmV0038UpdateJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038UpdateJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0038UpdateJobWithResponse(ctx context.Context, jobId string, body SlurmV0038UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0038UpdateJobResponse, error) {
	rsp, err := c.SlurmV0038UpdateJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038UpdateJobResponse(rsp)
}

// SlurmV0038GetJobsWithResponse request returning *SlurmV0038GetJobsResponse
func (c *ClientWithResponses) SlurmV0038GetJobsWithResponse(ctx context.Context, params *SlurmV0038GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetJobsResponse, error) {
	rsp, err := c.SlurmV0038GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetJobsResponse(rsp)
}

// SlurmV0038SlurmctldGetLicensesWithResponse request returning *SlurmV0038SlurmctldGetLicensesResponse
func (c *ClientWithResponses) SlurmV0038SlurmctldGetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0038SlurmctldGetLicensesResponse, error) {
	rsp, err := c.SlurmV0038SlurmctldGetLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038SlurmctldGetLicensesResponse(rsp)
}

// SlurmV0038GetNodeWithResponse request returning *SlurmV0038GetNodeResponse
func (c *ClientWithResponses) SlurmV0038GetNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0038GetNodeResponse, error) {
	rsp, err := c.SlurmV0038GetNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetNodeResponse(rsp)
}

// SlurmV0038GetNodesWithResponse request returning *SlurmV0038GetNodesResponse
func (c *ClientWithResponses) SlurmV0038GetNodesWithResponse(ctx context.Context, params *SlurmV0038GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetNodesResponse, error) {
	rsp, err := c.SlurmV0038GetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetNodesResponse(rsp)
}

// SlurmV0038GetPartitionWithResponse request returning *SlurmV0038GetPartitionResponse
func (c *ClientWithResponses) SlurmV0038GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0038GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetPartitionResponse, error) {
	rsp, err := c.SlurmV0038GetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetPartitionResponse(rsp)
}

// SlurmV0038GetPartitionsWithResponse request returning *SlurmV0038GetPartitionsResponse
func (c *ClientWithResponses) SlurmV0038GetPartitionsWithResponse(ctx context.Context, params *SlurmV0038GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetPartitionsResponse, error) {
	rsp, err := c.SlurmV0038GetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetPartitionsResponse(rsp)
}

// SlurmV0038PingWithResponse request returning *SlurmV0038PingResponse
func (c *ClientWithResponses) SlurmV0038PingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0038PingResponse, error) {
	rsp, err := c.SlurmV0038Ping(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038PingResponse(rsp)
}

// SlurmV0038GetReservationWithResponse request returning *SlurmV0038GetReservationResponse
func (c *ClientWithResponses) SlurmV0038GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0038GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetReservationResponse, error) {
	rsp, err := c.SlurmV0038GetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetReservationResponse(rsp)
}

// SlurmV0038GetReservationsWithResponse request returning *SlurmV0038GetReservationsResponse
func (c *ClientWithResponses) SlurmV0038GetReservationsWithResponse(ctx context.Context, params *SlurmV0038GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0038GetReservationsResponse, error) {
	rsp, err := c.SlurmV0038GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0038GetReservationsResponse(rsp)
}

// ParseGetOpenapiResponse parses an HTTP response from a GetOpenapiWithResponse call
func ParseGetOpenapiResponse(rsp *http.Response) (*GetOpenapiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenapiJsonResponse parses an HTTP response from a GetOpenapiJsonWithResponse call
func ParseGetOpenapiJsonResponse(rsp *http.Response) (*GetOpenapiJsonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiJsonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenapiYamlResponse parses an HTTP response from a GetOpenapiYamlWithResponse call
func ParseGetOpenapiYamlResponse(rsp *http.Response) (*GetOpenapiYamlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiYamlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetOpenapiV3Response parses an HTTP response from a GetOpenapiV3WithResponse call
func ParseGetOpenapiV3Response(rsp *http.Response) (*GetOpenapiV3Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiV3Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlurmV0038DiagResponse parses an HTTP response from a SlurmV0038DiagWithResponse call
func ParseSlurmV0038DiagResponse(rsp *http.Response) (*SlurmV0038DiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038DiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038Diag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038Diag
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038SubmitJobResponse parses an HTTP response from a SlurmV0038SubmitJobWithResponse call
func ParseSlurmV0038SubmitJobResponse(rsp *http.Response) (*SlurmV0038SubmitJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038SubmitJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038JobSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038JobSubmissionResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038CancelJobResponse parses an HTTP response from a SlurmV0038CancelJobWithResponse call
func ParseSlurmV0038CancelJobResponse(rsp *http.Response) (*SlurmV0038CancelJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038CancelJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlurmV0038GetJobResponse parses an HTTP response from a SlurmV0038GetJobWithResponse call
func ParseSlurmV0038GetJobResponse(rsp *http.Response) (*SlurmV0038GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038JobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038JobsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmV0038UpdateJobResponse parses an HTTP response from a SlurmV0038UpdateJobWithResponse call
func ParseSlurmV0038UpdateJobResponse(rsp *http.Response) (*SlurmV0038UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSlurmV0038GetJobsResponse parses an HTTP response from a SlurmV0038GetJobsWithResponse call
func ParseSlurmV0038GetJobsResponse(rsp *http.Response) (*SlurmV0038GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038JobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038JobsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038SlurmctldGetLicensesResponse parses an HTTP response from a SlurmV0038SlurmctldGetLicensesWithResponse call
func ParseSlurmV0038SlurmctldGetLicensesResponse(rsp *http.Response) (*SlurmV0038SlurmctldGetLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038SlurmctldGetLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038Licenses
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038Licenses
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseSlurmV0038GetNodeResponse parses an HTTP response from a SlurmV0038GetNodeWithResponse call
func ParseSlurmV0038GetNodeResponse(rsp *http.Response) (*SlurmV0038GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038NodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038NodesResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038GetNodesResponse parses an HTTP response from a SlurmV0038GetNodesWithResponse call
func ParseSlurmV0038GetNodesResponse(rsp *http.Response) (*SlurmV0038GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038NodesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038NodesResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038GetPartitionResponse parses an HTTP response from a SlurmV0038GetPartitionWithResponse call
func ParseSlurmV0038GetPartitionResponse(rsp *http.Response) (*SlurmV0038GetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038PartitionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038PartitionsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038GetPartitionsResponse parses an HTTP response from a SlurmV0038GetPartitionsWithResponse call
func ParseSlurmV0038GetPartitionsResponse(rsp *http.Response) (*SlurmV0038GetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038PartitionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038PartitionsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038PingResponse parses an HTTP response from a SlurmV0038PingWithResponse call
func ParseSlurmV0038PingResponse(rsp *http.Response) (*SlurmV0038PingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038PingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038Pings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038Pings
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038GetReservationResponse parses an HTTP response from a SlurmV0038GetReservationWithResponse call
func ParseSlurmV0038GetReservationResponse(rsp *http.Response) (*SlurmV0038GetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038ReservationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038ReservationsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0038GetReservationsResponse parses an HTTP response from a SlurmV0038GetReservationsWithResponse call
func ParseSlurmV0038GetReservationsResponse(rsp *http.Response) (*SlurmV0038GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0038GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0038ReservationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0038Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0038ReservationsResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0038Errors
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}
